;;; -*- Mode: Lisp -*-

;; Copyright (C) 2013 Alexander aka CosmonauT Vynnyk
;;
;;  This file is part of dswm.
;;
;; dswm is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; dswm is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this software; see the file COPYING.  If not, see
;; <http://www.gnu.org/licenses/>.

;; Commentary:
;;
;; Dynamically loads DSWM into CL virtualmachine
;;
;; Code:

;; (load (make-pathname :directory '(:relative "src") :name "jabs-core" :type "lisp"))

(dolist (v '("jabs-packages" "jabs-logger" "jabs-re" "jabs-tools" "jabs-core"))
  (load (merge-pathnames
         (make-pathname :name v :type "lisp")
         (parse-namestring "@SRCDIR@"))))

;; (load (merge-pathnames (make-pathname :name "jabs-logger" :type "lisp") (parse-namestring "@SRCDIR@")))
;; (load (merge-pathnames (make-pathname :name "jabs-logger" :type "lisp") (parse-namestring "@SRCDIR@")))
;; (load (merge-pathnames (make-pathname :name "jabs-re" :type "lisp") (parse-namestring "@SRCDIR@")))
;; (load (merge-pathnames (make-pathname :name "jabs-tools" :type "lisp") (parse-namestring "@SRCDIR@")))
;; (load (merge-pathnames (make-pathname :name "jabs-core" :type "lisp") (parse-namestring "@SRCDIR@")))

(defpackage jab
  (:use :cl :tools@jabs :jabs :re@jabs)
  (:export :jab))

(in-package :jab)

(pushnew :jab *features*)

;; load argparse
(load (merge-pathnames (make-pathname
                        :directory
                        '(:relative "wrappers" "jab")
                        :name "jabs-argparse" :type "lisp")
                       (parse-namestring "@SRCDIR@")))

(defvar +version+ +jabs-version+)
(defvar *jabs-default-argument-parser* (make-argument-parser :description "Default argument parser"))
(defvar *jabs-argv-symbols* (make-hash-table :test 'equal))
(defvar *compiler-arguments* nil)
(defvar *lisp-debug* nil)
(defvar *lisp-quiet* nil)
(defvar *rounds* nil)
(defvar *bouts* nil)
(defvar *project* nil)

(defvar *build-jab-file* (make-pathname :name "build" :type "jab"))

(defconstant +usage+
  (concatenate 'string
               "USAGE: jab [OPTIONS] [bout|round@bout] [OPTIONS]
"
               "Application options:
 -h, --help-jabs              Show this help
 --help                       Show compiler toplevel help
 -c, --compiler               Use selected compiled, instead of default
 -d, --debug                  Enable debugger
 -q, --quiet                  Quiet mode
 -v, --verbose                Use verbose output
 -V, --version                Show JAB wrapper version
 -VV,                         Show JABS version

 --autogen-project            Generates simple buildfile (``build.jab'' by default. See -f option)
                              available options:
                                -Dtmpl-version=<number>
                                -Dtmpl-skeleton=<skeleton_name>
 --serve                      Start swank server to work with app interactively
 -f, --buildfile=FILENAME     Use selected buildfile instead of default

 -D<some-parameter>           Give direct parameter to JABS (ex. jab -Dversion returns JABS version, but not JAB)
"

 ;; -p, --projects               Build project, or comma-separated projects
 ;; --hit                        Build only selected hits from selected
 ;;                              projects (not working, -p must be set)
 ;; -f, --buildfile=FILENAME     Use selected buildfile instead of default
 ;;                              default build.jab
 ;; -c, --compiler               Use selected compiled, instead of default
 ;;                              supported compilers: sbcl, clisp, ccl, cmucl
 ;; -o, --options                Additional compiler options
 ;; --no-recursive               Do not build all projects recursively
 ;; -e, --eval                   Eval expression before of after build
 ;; -d, --debug                  Enable debugger
 ;; -q, --quiet                  Quiet mode
 ;; --logfile=FILENAME           Use logfile as standard output
 ;; --error-logfile=FILENAME     Use logfile as standard error output
 ;; --exclude=dir1,dir2          Comma separated directories, excluded from
 ;;                              recursive build (inactive with --non-recursive)
 ;; -V, --version                Show version

 ;; --sbcl=PATH-TO-SBCL          Use PATH-TO-SBCL instead of the sbcl program
 ;;                              found in your PATH environment variable
 ;; --ccl=PATH-TO-CCL            Use PATH-TO-CCL instead of the ccl program
 ;;                              found in your PATH environment variable
 ;; --clisp=PATH-TO-CLISP        Use PATH-TO-CLISP instead of the clisp program
 ;;                              found in your PATH environment variable
 ;; --cmucl=PATH-TO-CMUCL        Use PATH-TO-CMUCL instead of the cmucl program
 ;;                              found in your PATH environment variable
 ;; -b, --bout                   Run selected bouts instead default for project
 ;; --nodeps                     Do not use hit dependencies resolution (working
 ;;                              only with --deps-strategy)
 ;; --no-bouts                   Use bout-based hit running strategy
 ;; --fail-on-error              Do not skip application errors
 ;; -v, --verbose                Use verbose output

 ;; -D<some-parameter>           Give direct parameter to JABS (ex. jab -Dversion returns JABS version, but not JAB)

 ;; --self-install               Install JABS to specified location
 ;; --prefix                     Set PREFIX to install JABS (working only with --self-install) [/usr/local/ by default]
 ;; --bindir                     Set binary directory for JABS installation (working only with --self-install)  [PREFIX/bin/ by default]
 ;; --libdir                     Set directory with libraries for JABS installation (working only with --self-install) [PREFIX/lib/ by default]
 ;; --sysconfigdir               Set directory with configfiles for JABS installation (working only with --self-install) [PREFIX/etc/ by default]
 ;; --datarootdir                Set data directory for JABS installation (working only with --self-install) [PREFIX/share/ by default]
 ;; --docdir                     Set documentation directory for JABS installation (working only with --self-install) [PREFIX/doc/ by default]
 ;; --mandir                     Set manuals directory for JABS installation (working only with --self-install) [PREFIX/man/ by default]

 ;; --generate-buildfile         Generates simple buildfile (build.jab by default. See -f option)

;; --no-quit                    Don`t exit after perform all operations
               ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro bind-argv (key symbol &key (action :store) (type :string) default help)
  `(labels ((rm-first-minuses (list)
              (if (char-equal #\- (car list))
                  (rm-first-minuses (cdr list))
                  list)))
     (let ((dest (concatenate 'string (rm-first-minuses (concatenate 'list ,key)))))
       (add-argument *jabs-default-argument-parser*
                     :keys '(,key) :help ,help :destination dest
                     :type ,type :action ,action :DEFAULT ,default)
       (setf (gethash dest *jabs-argv-symbols*) ,symbol))))

(defmacro process-argv (destination)
  `(let ((argvalue (get-parsed-argument-value ,destination (parse-args *jabs-default-argument-parser*)))
         (argsymbol (gethash ,destination *jabs-argv-symbols*)))
     (if (and argsymbol argvalue)
         (progn
           (jlog:dbg "Processing argv ``~a''" ,destination)
           (funcall argsymbol argvalue) t))))

(defun push-compiler-argument (argument &optional value)
  "Push argument to jabs"
  (if (not (null value))
      (push (concatenate 'string
                         "-D" (princ-to-string argument)
                         "=" (princ-to-string value))
            *compiler-arguments*)
    (push (concatenate 'string
                       "-D" (princ-to-string argument))
          *compiler-arguments*)))

(defun process-direct-jabs-arguments ()
  "Process direct compiler arguments"
  (dolist (v (argv))
    (when (begin-scan "-D" v)
      (progn
        (jlog:dbg "Pushing compiler argument ``~a''" v)
        (push v *compiler-arguments*)))))

(defun process-bouts-and-rounds ()
  "Process direct compiler arguments"
  (dolist (v (argv))
    (when (and (not (null v)) (not (begin-scan "-D" v)) (not (begin-scan "-" v)))
      (let ((round
             (if (scan *jabs-universal-delimiter* v)
		 (car (split (car (concatenate 'list *jabs-universal-delimiter*)) v))
	         v))
            (bout
             (when (scan *jabs-universal-delimiter* v)
	       (cadr (split (car (concatenate 'list *jabs-universal-delimiter*)) v)))))
        ;;
        (jlog:dbg "Processing (round@)bout ``~a''" v)
        (push round *rounds*)
        (push bout *bouts*)
        ))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-argv "-q"
           #'(lambda (x)
               (declare (ignore x))
               (push-compiler-argument "quiet" "t")
               (setf jlog:*log-level* "CRITICAL")) :action :store-t)

(bind-argv "-v"
           #'(lambda (x)
               (declare (ignore x))
                 (push-compiler-argument "verbose" "t")
                 (setf jlog:*log-level* "INFO")) :action :store-t)

(bind-argv "-d"
           #'(lambda (x)
               (declare (ignore x))
               (push-compiler-argument "debug" "t")
               (setf jlog:*log-level* "DEBUG")) :action :store-t)

(bind-argv "-V"
           #'(lambda (x)
               (declare (ignore x))
               (format t "(Just (Another (Builder :version \"~a\")))~%" +version+)
               (terminate 0)
               )
           :action :store-t)

(bind-argv "-VV"
           #'(lambda (x)
               (declare (ignore x))
               ;; (format t "(Just (Another (Builder (System :version \"~a\"))))~%" +jabs-version+)
               (push-compiler-argument "version"))
           :action :store-t)

(bind-argv "-h"
           #'(lambda (x)
               (declare (ignore x))
               (format t "~a~%" +usage+)
               (terminate 0))
           :action :store-t)

;; (bind-argv "-p"
;;            #'(lambda (x)
;;                (setf *project* x)
;;                (push-compiler-argument "project" x)))

(bind-argv "--autogen-project"
           #'(lambda (x)
               (declare (ignore x))
               (push-compiler-argument "bouts" "tmpl-mkproject")
               (push-compiler-argument "plugins" "tmpl@generic")
               )
           :action :store-t)

(bind-argv "--autogen-plugin"
           #'(lambda (x)
               (declare (ignore x))
               (push-compiler-argument "bouts" "tmpl-mkplugin")
               (push-compiler-argument "plugins" "tmpl@generic")
               )
           :action :store-t)

(bind-argv "--serve"
           #'(lambda (x)
               (declare (ignore x))
               (push-compiler-argument "bouts" "swank-server")
               (push-compiler-argument "plugins" "quicklisp@repository,swank@generic") ; TODO: load project's plugins too
               )
           :action :store-t)

;;;;
;;;; top-level function
;;;;
(defun jab ()
  ;; process direct arguments initially. Will be at the end of argument list
  (process-direct-jabs-arguments)
  ;; process bouts and rounds
  (process-bouts-and-rounds)
  ;; process regular arguments
  (dolist (arg '("q" "v" "d" "V" "VV" "h" "p" "autogen-project"))
    (process-argv arg))
  ;; form bouts and rounds
  (labels ((concat-list (delimiter &optional list)
             (cond ((null list) nil)
                   (t
                    (concatenate 'string (car list) delimiter (concat-list delimiter (cdr list)))))))
    (when *rounds* (push-compiler-argument "rounds" (end-cut "," (concat-list "," (reverse *rounds*)))))
    (when *bouts* (push-compiler-argument "bouts" (end-cut "," (concat-list "," (reverse *bouts*)))))
    )
  ;;
  (sb-ext:run-program "@SBCL_BIN@" (append
                                    '("--noinform" "--no-sysinit" "--no-userinit" "--non-interactive"
                                      "--load" "@SRCDIR@/jabs-loader.lisp")
                                    *compiler-arguments*)
                      :output *standard-output*
                      :error *error-output*)
  )
